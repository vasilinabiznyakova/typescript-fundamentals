Какие проблемы решает?
JS - слабая динамическая типизация
- позволяет работать с разными типами, при этом неявно их преобразуя (type coercion)
- тип определяется в рантайме (время выполнения програмы) а не на этапе компиляции и написания кода


Проблема

- Типы строгие для большого проекта это самодокументация
- Сложность в поддержке больших проектов (много данных нет четкого описания), 
для маленьких это необязательно в больших превращается в проблему тк проблемы с типами приходитсчч отлавливать в голове на этапе написания кода
- усложняется дебаг и тестирование кода
- усложняетс анализ кода (большая когнитивная нагрузка для анализа)
- отсутствие адекватного автокомлита в среде разработке


TS - JS
Тайпскрипт надмножество над JS, расширяет его добавляет все что связано с типизацией


Все же мы работаем с базовыми типами данных JS
 1) Примитивы (String, Number, BigInt, Boolean, Underfined, Null, Symbol) - хранятся в стеке по значению, значение просто копируются 
 
 2) Объекты = ссылочные типы данных(Объекты, функции, Date, массивы и т.д) - хранится адрес в памяти(в куче heap) потому при переприсваивании изменение одного обьекта ведет к ищзщменению второго


 Typescript

 работаем с такими же примитивами и создаем на их основе более слодные типы
 Это язык программирования со статической типизацией (явной или выводимой + структурной)

 Статическая типизация - типы проверяются на этапе компиляции а не в рантайме, она делится на:
 - Явная - это ту которую мы явно прописали
 - Выводимая это та где TS  сам принимает решение на основе переменной

 Структурная  (если у нас есть 2 типа с одинаковой стрктурой то они взаимозаменяемые) - что дает нам гибкость и возможность передавать разные переменные при условии что их типы совпадают


 В Тайпскрипт есть следующие типы данных:
 - примитивы (те же что в JS)
 - специальные типы (any unknown never void)
 - литералы ("red" | "green")
 - generic types
 - union/intersection(A|B, A&B)
 - составные типы (composite types) обьекты массивы и т.д.


 Как мыслить о типах? 
 Это множество, множестро строк, чисел, Boolean это примитивные множества но могут быть и слодные те обьекты составные типы. Одно множество может быть подмножеством или надмножеством другого.
 Над множествами также можно совершать операции, например 
 
 ***union (обьединение)

 let data: number | string;
 data = 5;
 data = "string";

 мы обьединили 2 типа и получили 3 множетсов которое может состоять или из того или из того
 коротко или то или то или пересечение


***пересесение подразумеват что только пересечение будет - логическое и = &

let value: number & string;
never - єто невозможно



Надтип(super type) и подтип (subtype)

SuperType - базовый класс, базовый тип от которого грубо говоря происходит наследование, может содержать меньше свойств и/или методов чем подтип
SubType - тот который наследует все свойства и методы надтипа +добавляет свои

Обьект подтипа может быть присвоен переменной надтипа обратное не всегда возможно без приведения типов

При присваивании типа идти от большего к меньшему ок

